# RabbitMq

### 应用场景 

以下场景你比较适合使用RabbitMQ。你有较少的事件（2万以上/秒）
并且需要通过复杂的路由逻辑去找到消费者、你希望消息传递是可靠的、你并不关心消息传递的顺序、
你需要现在就支持集群-节点级别的高可用或则说你需要7*24小时的付费支持（当然也可以通过论坛/IRC工具）。

RabbitMQ是以代理为中心。它专注于生产者与消费者之间的传递保证,并且认为消息的瞬时性优于持久性。

他们并不支持复杂的“过滤/查询”能力。
如果你需要，可以考虑在他们的上层使用Storm来进行过滤、计算、查询。或则使用类似Cassandra作为你的查询缓存。

RabbitMQ让代理自己维护消费状态（通过消息确认机制）-它使用Erlang的Mnusia 在代理集群进行传递状态维护。

RabbitMQ假设消费者总是在线的，并且不知道任何消息的“等待”(无论持续与否)（也就是说没有游标）。在RabbitMQ pre-2.0（2010）版本如果消费者过于缓慢将会挂掉。不过现在他支持在线和打包消费的消费者-不过通常来讲显然持续的大量消息放在代理中并不符合AMQP的主要设计思想。

RabbitMQ按照AMQP0.9.1的exchange标准提供丰富的路由能力。支持绑定和队列化模型。



两种解决方案都是运行在分布式集群中。但是RabbitMQ的思想是集群透明的，也就是说它是一个动态的代理。
Kafka则是集群明确的，强制要求生产者知道它的话题的消息是分区到几个节点中，这种思想的好处是提供一个分区内的有序递交。这比RabbitMQ暴露出来的基本上是无序递交来得更好（AMQP 0.9.1模型认为“单生产通道、单交流、单队列、单消费者通道”是有序递交的必要条件）

另一方面来说，Kafka假设生产者为他们的时间表生成大量的事件流-没有任何地方可以对生产者进行节流。因为如果数据太庞大，消费者就会变慢。Kafka通过在事件洪水和期望用自己的方法去消费的消费者（有些是在线的，有些是平时离线，仅仅一个小时甚至一天一次进行打包消费）之间提供"减震器"。
Kafka能递交“至少一次”每个分区（为了维持有序传递），就像RabbitMQ,不过是用了一个非常不同的方式。

从性能上来讲，如果你需要有序的持久化消息传递，目前Kafka看起来没有任何的竞争对手。《Kafka目前来说在综合基准的性能条款上远远超过RabbitMQ.》这篇文章中使用双节点集群，每个节点使用6-disk RAID 10的情况下可以达到每秒发布50w条消息和每秒消费2.2w条消息。